{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isNumber } from '@stdlib/assert-is-number';\nimport { isPrimitive as isInteger } from '@stdlib/assert-is-integer';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport isStruct from '@stdlib/assert-is-struct';\nimport isComplexLike from '@stdlib/assert-is-complex-like';\nimport isComplexDataType from '@stdlib/ndarray-base-assert-is-complex-floating-point-data-type';\nimport isBooleanDataType from '@stdlib/ndarray-base-assert-is-boolean-data-type';\nimport isRealFloatingDataType from '@stdlib/ndarray-base-assert-is-real-floating-point-data-type';\nimport isUnsignedIntegerDataType from '@stdlib/ndarray-base-assert-is-unsigned-integer-data-type';\nimport isSignedIntegerDataType from '@stdlib/ndarray-base-assert-is-signed-integer-data-type';\nimport isStructDataType from '@stdlib/ndarray-base-assert-is-struct-data-type';\nimport isSafeCast from '@stdlib/ndarray-base-assert-is-safe-data-type-cast';\nimport minDataType from '@stdlib/ndarray-min-dtype';\nimport minSignedIntegerDataType from '@stdlib/ndarray-base-min-signed-integer-dtype';\nimport resolveStr from '@stdlib/ndarray-base-dtype-resolve-str';\n\n\n// FUNCTIONS //\n\n/**\n* Verifies whether a provided value can be safely cast to a \"generic\" or unknown data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - data type\n* @returns {boolean} boolean result\n*\n* @example\n* var out = validateGeneric( 3, 'generic' );\n* // returns true\n*/\nfunction validateGeneric() {\n\treturn true;\n}\n\n/**\n* Verifies whether a provided value can be safely cast to a boolean data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - data type\n* @returns {boolean} boolean result\n*\n* @example\n* var out = validateBoolean( true, 'bool' );\n* // returns true\n*\n* @example\n* import Complex128 from '@stdlib/complex-float64-ctor';\n*\n* var out = validateBoolean( new Complex128( 5.0, 6.0 ), 'bool' );\n* // returns false\n*/\nfunction validateBoolean( value ) {\n\treturn isBoolean( value );\n}\n\n/**\n* Verifies whether a provided value can be safely cast to a real-valued floating-point data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - data type\n* @returns {boolean} boolean result\n*\n* @example\n* var out = validateRealFloating( 3.14, 'float64' );\n* // returns true\n*\n* @example\n* import Complex128 from '@stdlib/complex-float64-ctor';\n*\n* var out = validateRealFloating( new Complex128( 5.0, 6.0 ), 'float64' );\n* // returns false\n*/\nfunction validateRealFloating( value ) {\n\treturn isNumber( value );\n}\n\n/**\n* Verifies whether a provided value can be safely cast to a complex-valued floating-point data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - data type\n* @returns {boolean} boolean result\n*\n* @example\n* import Complex128 from '@stdlib/complex-float64-ctor';\n*\n* var out = validateComplexFloating( new Complex128( 5.0, 6.0 ), 'complex128' );\n* // returns true\n*\n* @example\n* var out = validateComplexFloating( {}, 'complex128' );\n* // returns false\n*/\nfunction validateComplexFloating( value ) {\n\treturn ( isNumber( value ) || isComplexLike( value ) );\n}\n\n/**\n* Verifies whether a provided value can be safely cast to a signed integer data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - data type\n* @returns {boolean} boolean result\n*\n* @example\n* var out = validateSignedInteger( 3, 'int32' );\n* // returns true\n*\n* @example\n* var out = validateSignedInteger( 3.14, 'int32' );\n* // returns false\n*/\nfunction validateSignedInteger( value, dtype ) {\n\treturn ( isInteger( value ) && isSafeCast( minSignedIntegerDataType( value ), dtype ) ); // eslint-disable-line max-len\n}\n\n/**\n* Verifies whether a provided value can be safely cast to an unsigned integer data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - array data type\n* @returns {boolean} boolean result\n*\n* @example\n* var out = validateUnsignedInteger( 3, 'uint32' );\n* // returns true\n*\n* @example\n* var out = validateUnsignedInteger( -3, 'uint32' );\n* // returns false\n*/\nfunction validateUnsignedInteger( value, dtype ) {\n\treturn ( isInteger( value ) && isSafeCast( minDataType( value ), dtype ) );\n}\n\n/**\n* Verifies whether a provided value can be safely cast to a binary data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - array data type\n* @returns {boolean} boolean result\n*\n* @example\n* var out = validateBinary( 3, 'binary' );\n* // returns true\n*\n* @example\n* var out = validateBinary( -3, 'binary' );\n* // returns false\n*/\nfunction validateBinary( value ) {\n\treturn ( isInteger( value ) && minDataType( value ) === 'uint8' );\n}\n\n/**\n* Verifies whether a provided value can be safely cast to a struct data type.\n*\n* @private\n* @param {*} value - input value\n* @param {string} dtype - array data type\n* @returns {boolean} boolean result\n*\n* @example\n* import structFactory from '@stdlib/dstructs-struct';\n*\n* var schema = [\n*     {\n*         'name': 'value',\n*         'type': 'float64'\n*     }\n* ];\n* var Struct = structFactory( schema );\n*\n* var data = {\n*     'value': 3.0\n* };\n* var s = new Struct( data );\n*\n* var out = validateStruct( s, '|<float64>[0,8]|' );\n* // returns true\n*\n* @example\n* import structFactory from '@stdlib/dstructs-struct';\n*\n* var schema = [\n*     {\n*         'name': 'value',\n*         'type': 'float32'\n*     }\n* ];\n* var Struct = structFactory( schema );\n*\n* var data = {\n*     'value': 3.0\n* };\n* var s = new Struct( data );\n*\n* var out = validateStruct( s, '|<float64>[0,8]|' );\n* // returns false\n*/\nfunction validateStruct( value, dtype ) {\n\tvar o = {\n\t\t'format': 'layout'\n\t};\n\treturn ( isStruct( value ) && value.toString( o ) === dtype );\n}\n\n\n// MAIN //\n\n/**\n* Returns a boolean indicating whether a scalar value can be safely cast or, for floating-point data types, downcast to specified ndarray data type.\n*\n* @param {*} value - scalar value\n* @param {*} dtype - ndarray data type\n* @returns {boolean} boolean indicating whether a scalar value can be safely cast\n*\n* @example\n* var bool = isScalarMostlySafeCompatible( 3.0, 'float64' );\n* // returns true\n*\n* @example\n* var bool = isScalarMostlySafeCompatible( 3.14, 'int32' );\n* // returns false\n*\n* @example\n* var bool = isScalarMostlySafeCompatible( -1, 'uint32' );\n* // returns false\n*/\nfunction isScalarMostlySafeCompatible( value, dtype ) { // eslint-disable-line id-length\n\tvar dt = resolveStr( dtype ) || ''; // note: empty string when unable to resolve a second argument to a data type string\n\tif ( dt === 'generic' ) {\n\t\treturn validateGeneric( value, dt );\n\t}\n\tif ( dt === 'binary' ) {\n\t\treturn validateBinary( value, dt );\n\t}\n\tif ( isRealFloatingDataType( dt ) ) {\n\t\treturn validateRealFloating( value, dt );\n\t}\n\tif ( isUnsignedIntegerDataType( dt ) ) {\n\t\treturn validateUnsignedInteger( value, dt );\n\t}\n\tif ( isSignedIntegerDataType( dt ) ) {\n\t\treturn validateSignedInteger( value, dt );\n\t}\n\tif ( isBooleanDataType( dt ) ) {\n\t\treturn validateBoolean( value, dt );\n\t}\n\tif ( isComplexDataType( dt ) ) {\n\t\treturn validateComplexFloating( value, dt );\n\t}\n\tif ( isStructDataType( dtype ) ) {\n\t\treturn validateStruct( value, dt );\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nexport default isScalarMostlySafeCompatible;\n"],"names":["isScalarMostlySafeCompatible","value","dtype","dt","resolveStr","isInteger","minDataType","validateBinary","isRealFloatingDataType","isNumber","validateRealFloating","isUnsignedIntegerDataType","isSafeCast","validateUnsignedInteger","isSignedIntegerDataType","minSignedIntegerDataType","validateSignedInteger","isBooleanDataType","isBoolean","validateBoolean","isComplexDataType","isComplexLike","validateComplexFloating","isStructDataType","isStruct","toString","format","validateStruct"],"mappings":";;koDAkQA,SAASA,EAA8BC,EAAOC,GAC7C,IAAIC,EAAKC,EAAYF,IAAW,GAChC,MAAY,YAAPC,IAGO,WAAPA,EApFN,SAAyBF,GACxB,OAASI,EAAWJ,IAAoC,UAAzBK,EAAaL,EAC7C,CAmFSM,CAAgBN,GAEnBO,EAAwBL,GAzK9B,SAA+BF,GAC9B,OAAOQ,EAAUR,EAClB,CAwKSS,CAAsBT,GAEzBU,EAA2BR,GA9GjC,SAAkCF,EAAOC,GACxC,OAASG,EAAWJ,IAAWW,EAAYN,EAAaL,GAASC,EAClE,CA6GSW,CAAyBZ,EAAOE,GAEnCW,EAAyBX,GArI/B,SAAgCF,EAAOC,GACtC,OAASG,EAAWJ,IAAWW,EAAYG,EAA0Bd,GAASC,EAC/E,CAoISc,CAAuBf,EAAOE,GAEjCc,EAAmBd,GAxMzB,SAA0BF,GACzB,OAAOiB,EAAWjB,EACnB,CAuMSkB,CAAiBlB,GAEpBmB,EAAmBjB,GA/JzB,SAAkCF,GACjC,OAASQ,EAAUR,IAAWoB,EAAepB,EAC9C,CA8JSqB,CAAyBrB,KAE5BsB,EAAkBrB,IApDxB,SAAyBD,EAAOC,GAI/B,OAASsB,EAAUvB,IAAWA,EAAMwB,SAH5B,CACPC,OAAU,aAE2CxB,CACvD,CAgDSyB,CAAgB1B,EAAOE,GAGhC"}